{"pages":[],"posts":[{"title":"CSS Position","text":"CSS Position (static, relative, absolute, fixed) 저번 포스트에서는 BFC에 대해 알아 봤으니 이번에도 css 레이아웃을 잡을때 유용한 position 속성을 다뤄보도록하겠습니다. Position 속성은 html문서내 요소를 배치하는 방법을 지정해주는 속성으로static, relative, absolute, fixed 그리고 아직은 일부 브라우저에선 지원하지 않는 sticky이렇게 5가지의 값을 줄수있고 기본값으로는 static이 설정됩니다. sticky는 다룰 내용이 좀 많아 다른 포스트에서 알아보고그 외 4가지 속성을 좀 더 구체적으로 살펴보면서 각자의 특성을 이해해보도록 하겠습니다. static123456789101112131415161718192021position: static;``` 앞에서 말했듯이 포지션 속성(position property)의 기본값입니다. 다른 속성보다 눈에 익숙하지않는 이유는 기본값이라 굳이 명시를 하지 않기 때문입니다. static 요소를 만들면 일반적인 흐름을 (normal flow) 따라 차례대로 왼쪽에서 오른쪽, 위에서 아래쪽으로 쌓이게 됩니다. &lt;iframe height=&quot;265&quot; style=&quot;width: 100%;&quot; scrolling=&quot;no&quot; title=&quot;qBNrWoE&quot; src=&quot;https://codepen.io/minki607/embed/qBNrWoE?height=265&amp;theme-id=dark&amp;default-tab=css,result&quot; frameborder=&quot;no&quot; loading=&quot;lazy&quot; allowtransparency=&quot;true&quot; allowfullscreen=&quot;true&quot;&gt; See the Pen &lt;a href='https://codepen.io/minki607/pen/qBNrWoE'&gt;qBNrWoE&lt;/a&gt; by Min Gee (&lt;a href='https://codepen.io/minki607'&gt;@minki607&lt;/a&gt;) on &lt;a href='https://codepen.io'&gt;CodePen&lt;/a&gt;.&lt;/iframe&gt;static 요소에는 offset값을 줘도 **아무 변화가 일어나지 않습니다.** 요소가 겹쳐져 있을때의 수직위치를 정해주는 z-index 값 또한 적용되지 않습니다. 여기서 offset이란 top, left, right, bottom 값을 의미하고 기준이 되는곳으로부터 얼마만큼 떨어져있는지를 나타내기 위해 필요한 속성입니다. 어떻게 쓰이는지는 바로 다음 포지션 속성을 알아볼때 설명하도록 하겠습니다.## relative ```cssposition: relative; 이값이 적용 되더라도 아직까진 일반적인 문서의 흐름을 유지 하면서 배치가 됩니다.static과 다른점은 이 값을 가진 요소는 static 위치 였을때를 기준으로 offset을 통해 상대적인 (relative) 위치에 배치할수 있다는 점입니다. See the Pen YzWZzNr by Min Gee (@minki607) on CodePen. position:relative로 설정하고 offset을 주지않으면 static과 똑같은 위치에 있지만위에 예제처럼 top: 10px, right:50px offset이 들어가면 본 위치를 기준으로배치가 되는걸 볼수있습니다. position: relative로 지정된 요소들의 특징으로는 다른 요소들의 위치에 영향을 주지 않는다는 겁니다. 예를들어 position: relative인 요소가 아래에 내려갔다고 해서 position: static값을 가진 요소들이 그 빈공간을 채우기 위해 위쪽으로 이동하지는 않습니다. absolute1position: absolute; 이값이 적용된 요소들은 일반적인 문서의 흐름에서 제외됩니다.relative가 자신의 static위치를 기준으로 움직였다면, absolute는 position값이 static이 아닌 조상 요소를 기준으로 요소를 배치하게 됩니다. 만약 조상요소중 static이외의 값을 가진 요소가 없다면 html까지 거슬러 올라가 페이지 전체를 기준으로 위치가 결정되는걸 볼수 있습니다. 주로 position: relative가 많이 쓰여 position값이 relative인 조상요소만 기준점이 가능하다고 생각할수도 있지만 position:absolute인 요소에 position: absolute를 지정할수도 있습니다. position이 absolute인 요소에게 offset을 주지않으면 auto 값이 주어지는데 이는 static이였을때를 기준으로 위치시키기 때문에 조상 요소 기준으로 offset값을 줘서 원하는곳에 위치하게 해야합니다. 잘 사용하면 원하는 레이아웃을 쉽게 구현해줄 강력한 속성이지만 잘못 사용하거나 설계없이 남발을 하게 되면 웹의 구조가 무너져 버릴수도 있으니 주의하며 사용해야 합니다. 아래 예제는 부모 요소가 두개의 자식을 갖고 있는 형태로 position을 변경한적이 없으니 기본값인position:static이 적용되어 있는상태입니다. See the Pen position:absolute by Min Gee (@minki607) on CodePen. 여기서 자식요소 2번(child 2)에게 position:absolute 값을 줘보겠습니다. See the Pen KKMWgmg by Min Gee (@minki607) on CodePen. 2번째 자식요소는 이제 일반적인 문서의 흐름에서 제외되기 때문에 부모 요소가 이를 더이상 자식 요소로 인식하지 않고 첫번째 자식만을 감싸게 됩니다. 두번째 자식은 이제 정상적인 블록\u001c레벨의 요소처럼 작동하지않고 static 포지션이 아닌 조상요소를 기준으로 배치가 됩니다. 위 예시에서 static이외의 요소가 없었는데도 불구하고 최상위 html을 기준으로 배치가 되지 않았던 이유는 offset값을 주지 않았기 때문입니다. 위에서 언급을 했듯이, offset을 주지 않으면 static이였을때를 기준으로 위치시키기 때문에 원래 자리를 유지하게 되는겁니다. 화면 좌측상단에 위치 시키고 싶다면 top: 0; left: 0; 값을 주면 아래와 같이 정상적으로 원하는 위치에 배치되는걸 볼수 있습니다. See the Pen MWepjOm by Min Gee (@minki607) on CodePen. 하지면 이런식으로 html을 기준으로 배치되는 경우는 흔치 않고 보통 상위요소에게 position:relative이나 position:absolute값을 줘서 그 요소를 기준으로 배치를 하는게 일반적입니다. 아래 예제에서는 부모 container에게 position: relative값을 줘 기준으로 삼고 bottom: 0; right: 0 값을 통해 우측하단에 배치 시켰습니다. See the Pen position 예제 by Min Gee (@minki607) on CodePen. fixed1position: fixed; fixed도 absolute랑 마찬가치로 일반적인 문서 흐름에서 제외시키는 속성입니다. absolute와 다른점은 viewport를 기준으로 배치가 된다는겁니다. absolute 요소의 경우 스크롤을 내리다보면 언젠간 화면에서 사라지지만 fixed된 요소는 말 그대로 고정되어 스크롤을 무한대로 내리게 된다해도 화면상 똑같은 위치에 있게 됩니다. 그럼 position:fixed값을 줘 보도록 하겠습니다. See the Pen ZEOepPr by Min Gee (@minki607) on CodePen. 스크롤을 계속 내려도 똑같은 위치에 배치되어 있는걸 볼수 있습니다. 이 역시 offset값을 사용해 viewport를 기준으로 위치를 변경할수도 있습니다. 위 예제와 같이 항상 화면에 띄어져있는 버튼을 위치하거나 항상 상단에 고정되어있는 navigation을 만들기 위해 많이 쓰입니다. 참고 자료 position CSS - MDN WEB DOCS","link":"/2020/10/25/CSS-Position/"},{"title":"BFC란무엇인가","text":"BLOCK FORMATTING CONTEXT (BFC)BFC란 용어는 들어보지 못했어도 아마 html/css로 레이아웃 작성을 해봤다면 이미 BFC의 원리는 알고 있을 가능성이 크다. normal flow일단 html에 작성된 요소들의 위치를 정하는 방법은 여러가지 있는데, 일반적인 상황에서 각각의 요소들이 배치되는 순서를 normal-flow 라고 한다. 이런식으로 블록요소들은 기본적으로 위에서 아래로 배치되고 인라인요소들은 왼쪽부터 시작해 오른쪽으로 배치된다. BFC &amp; IFCnormal flow에는 두가지 배치 방식이 있는데 그중 한가지가 Block Formatting Context(BFC) 그리고 Inline Formatting Context(IFC) 다. BFC는 BFC 영역에 포함된 요소들을 세로로 배치할수 있도록 도와주는 역활을 하고 IFC 는 가로로 배치할수 있게 해준다. BFC는 레이아웃 안의 미니 레이아웃이라고 생각하면 될거 같다. BFC가 생성 되면 내부의 모든 요소들은 이 Block Context안에 속하게 된다. 이런 특성때문에 float된 요소들의 레이아웃을 잡을때 아직까지도 많이 사용하고 있다. BFC 와 float보통 아래와 같이 텍스트 옆에 요소가 float된 레이아웃을 만든다면 이런 결과가 나올거다. See the Pen dyXNqPq by Min Gee (@minki607) on CodePen. 이렇게 보면 아무 문제 없어 보이지만 만약 텍스트가 지금보다 적다면 어떨까? See the Pen BazpOKa by Min Gee (@minki607) on CodePen. 부모요소인 outer가 float된 요소를 담지못하는걸 볼수 있다. 이걸 해결해주기 위해 부모요소에게 overflow:hidden(또는 auto) 를 주며 outer요소를 BFC로 명시해주는거다. MDN에 따르면 다음에 경우 BFC가 생성된다고 한다. html root 태그 (body 태그는 만들어지지 않는다) none을 제외한 float position: fixed, absolute display: inline-block, table, table-cell, table-caption overflow: visible을 제외한 모든 값 display: flow-root (일부 브라우저만 작동) display: flex, inline-flex, grid, inline-grid BFC가 생성되면 다음과 같이 동작하는걸 볼수 있다. See the Pen LYZxJWg by Min Gee (@minki607) on CodePen. 짧은 텍스트임에도 불구하고 float된 요소의 높이가 부모요소에게 인식이 되며 담긴걸 볼수 있다. BFC에 또 다른 특성으로는 마진 병합(margin collapsion)을 방지 할수 있다는 것이다. 마진 병합은 요소들의 마진값이 겹칠 경우 더 큰 마진만 적용되는 현상을 일컫는다. 예를들어 아래에 예제를 보면 See the Pen vYKgzVB by Min Gee (@minki607) on CodePen. .p 에 마진을 20px 줬음에도 텍스트영역으로 표시된 위 아래에 마진 병합현상이 일어나 마진이 들어가지 않은걸 볼수 있다. 여기서 outer영역을 bfc로 생성하면 마진 병합이 일어나지 않고 동일한 마진이 상하좌우로 주어진 것을 볼수 있다. See the Pen wvWgERo by Min Gee (@minki607) on CodePen. 사실 예전에는 개념을 이해하기 보단 그냥 작동되는법만 찾아 문제를 해결만 하려다보니 이런 용어들은 그냥 대수롭지 않게 지나쳤던거 같다. 그냥 overflow: hidden 을 주니 문제가 해결 됐고 그래서 더 이상 깊게 이해하려 하지 않았던거 같다. 이제라도 다시 개념들을 하나하나 배워보면서 전에 했던 방식이 왜 그렇게 작동했는지 알게되는거 같아 다행이다. 참고 자료들 Block formatting context - MDN WEB DOCSUnderstanding-CSS-LAYOUT - SmashingmagazineCSS 바로 알기 - Bono’s Blog","link":"/2020/10/25/BFC%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/"},{"title":"CSS 방법론 - BEM","text":"이번 포스트에서는 css 방법론중 하나인 BEM(Block Element Modifier)에 관해서 알아보겠습니다. CSS방법론이라고 하면 뭔가 거창해 보일수 있지만 그냥 클래스네임을 짓는 여러가지 방법들이라 볼수 있고 BEM은 그 여러 방법중에 자주 채택되는 방법중 하나 입니다. 그럼 왜 굳이 없어도 되는 방법론을 만들어서 사람을 귀찮게 하느냐 라고 할수도 있지만 사실 그 반대라고 생각합니다. 정해진 표기법이 있다면 팀원들끼리 의사소통을 원활하게 할수 있고 또 유지보수도 더 쉽게 할수 있다는 장점이있습니다. 만약 다른 프로젝트에 참여하게 된다해도 BEM으로 작성된 코드를보며 어떤 요소들이 어떻게 연결되어있고 작동 하는지 더 쉽게 이해할수도 있습니다. BEM은 Block Element Modifier의 줄임말이며 이 세가지의 단위를 기준으로 클래스 이름을 작성하게됩니다. Block 재사용이 가능한 독립적인 페이지 구성 요소입니다. 한곳에만 쓰일수 있는게 아니고 페이지 어디에서나 쓰일수 있는 컴포넌트 개념이라고 볼수있습니다. 제일 흔히 접할수 있는 블록으로는 header, footer, aside 이런 레이아웃의 기반이 되는 요소들이 있습니다. See the Pen zYBjKGd by Min Gee (@minki607) on CodePen. 여기서 헤더, 왼쪽사이드바, 뉴스기사, 오른쪽사이드바, 푸터 모두다 블록으로 분류할수있습니다. 이뿐만 아니라 헤더같은 블록안에서도 더 많은 블록들이 존재 할수 있습니다. 출처: An overview of BEM. Source: Adapted from BEM 2019b 헤더안에 메뉴 블록이 존재하고 그안에 로고 블록, 검색 블록, 로그인 블록등 수많은 블록들이 함께 존재할수 있습니다. 이 모두 독립적으로 사용될수 있는 컴포넌트이기 때문입니다. 이러한 블록들의 클래스 이름을 짓는 방법은 간단합니다. 그냥 그대로 class 이름을 목적에 맞게 소문자와 숫자만을 이용해 결정하면 됩니다. header면 .header, button이면 .btn 만약 하나의 단어로 설명이 되지 않는다면 .related-article 이런식으로 두개의 단어를 hypen(-) 으로 이어 주면 됩니다. 이런 방식은 BEM을 몰랐다 하더라도 자연스럽게 써왔을 것입니다. Element 블록을 구성하는 요소들을 말합니다. 블록은 독립적이지만 element는 의존적이며 자신이 속한 블럭내에서 온전한 의미를 가지기 때문에 element 부분만을 다른곳에서 재사용하는건 불가능합니다. 이런식으로 .menu 블록안에 4개의 탭 element가 존재할수 있습니다. 표기법은 .menu__tab 이런식으로 block 클래스이름과 element 클래스이름 사이에 두개의 언더스코어 (__)를 써주면 됩니다. 원활한 유지보수를 위해 블록과 앨리먼트 요소에게 css를 입힐때는: 클래스 이름 선택자만을 사용할것 (Use class name selector only)1.menu__tab{} 태그 이름 또는 아이디 선택자는 사용하지말것 (No tag name or ids) 다른 블록/앨리먼트 요소에 의존하는 선택자를 사용하지말것 (No dependency on other blocks/elements on a page)12!잘못된 방법.menu-block .menu__tab{} /*element를 선택할때는 .menu__tab만 쓰기*/ Modifier 블록이나 앨리먼트의 형태(appearance), 상태(state)나 행동(behaviour)을 변경하기 위해 사용. Modifier만을 단독적으로 사용할수는 없음. 예를들어 버튼의 모양 또는 비활성 상태를 나타내고자 할때 추가적으로 기입하여 사용할수있음. .form__button--disabled 이런식으로 블록 .form안에 앨리먼트인 .button 다음에modifer인 disabled가 오는식으로 표기할수있음. 또는 .form--color-pink 처럼 블록요소 다음에 바로 쓸수도 있음. 보통 첫번째 방식을 boolean type이라 하고 굳이 -disabled-true로 기입하지않고 뒤에 true를 생략하여 표시하는 방식이다. 두번째 방식은 key-value type 으로 key, value를 하이픈으로 연결하여 표시한 방식이다. (color-pink) 마지막으로 위 내용을 모두 적용한 아래의 예제를 살펴보겠습니다. 123456&lt;form class=&quot;form form--theme-xmas form--simple&quot;&gt; &lt;input class=&quot;form__input&quot; type=&quot;text&quot; /&gt; &lt;input class=&quot;form__submit form__submit--disabled&quot; type=&quot;submit&quot; /&gt;&lt;/form&gt; 출처: http://getbem.com/naming/ form이라는 블록이 두개의 input 앨리먼트를 담고있고 그중 하나의 input 앨리먼트가 disabled이라는 modifier를 갖고있는 구조입니다. form또한 theme-xmas 그리고 simple이라는 modifier가 적용되어있는걸 한눈에 볼수있습니다. 이런식으로 다른 사람이 작성한 코드임에도 각 요소들의 역활이나 구조들을 더 쉽게 파악할수 있습니다. 물론 BEM을 쓰지않았더라도 짧은 예제이기 때문에 이해하는데 큰 어려움은 없었겠지만 좀 더 체계적으로 다가갈수있는 방법임은 확실한것 같습니다. 물론 class이름이 필요이상으로 길어져 css 전처리기를 사용하지 않는다면 문제가 일어날수도 있지만 프로젝트 의도나 규모에 맞게 적절히 사용한다면 단점보다는 장점이 더 부각되어 보이는 방법론이라고 생각합니다. 필자도 대형프로젝트에 참여한적이 없어 BEM을 제대로 사용해본적이 없지만, 앞으로 많이 필요할것같다는 생각이들어 최대한 많이 써보며 익숙해지려고 합니다. 참고 자료http://getbem.com/https://css-tricks.com/bem-101/https://en.bem.info/methodology/naming-convention/","link":"/2020/11/01/CSS%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB-BEM/"},{"title":"Git 최초설정 및 사용해보기","text":"Git 설치후 사용하기오늘은 git를 사용법을 다시한번 복습해보았다.필자는 macOS를 사용하고 있었기에 별도의 설치는 필요없었지만윈도우라면 여기서 git을 깔고 진행하면 된다. 설치 완료후 terminal(맥)이나 git bash(윈도우)에서 버전 체크를 해보자 1$ git --version git version 2.20.1 (Apple Git-117)(버전은 다를수 있지만 이런식으로 뜨면 준비완료) config 정보 입력/변경이제 사용자이름과 이메일주소를 입력해보자. 이정보는 Github의 유저이름과 이메일 주소와는 무관하다 (물론 같아도 상관없지만).Git을 통해 커밋 할때마다 이 정보가 사용되고 github에 이 내용이 표시가 된다. 12$ git config --global user.name &quot;내 유저이름&quot;$ git config --global user.email &quot;내 이메일 주소&quot; 정상적으로 적용됐는지 확인해보자. 1$ git config --list 123user.name= 내 유저이름user.email= 내 이메일 주소...추가적인 정보들 만약 수정이 필요하면 아래 명령어 입력후 다시 입력을 해주면 된다. 123git config --unset --global user.name 또는 git config --unset --global user.email 본격적으로 GIT 활용하기프로젝트를 시작하는 방법 두가지 $ git init - 로컬 작업공간에서 시작해 문서/소스코드를 순차적으로 내보내기 $ git clone - github에서 remote repository 생성후 로컬 작업공간으로 클론 ⚠️ github 계정이 없다면 Github에서 계정 생성후 진행 git init 프로젝트 폴더 생성하기(이미 진행중인 프로젝트가 있다면 cd를 통해 디렉토리 변경) 12$ mkdir first-rep$ cd first-repo $ git init 명령으로 local repository로서 역할을 시작 (initialization) github에서 새로운 remote repository 생성후, 주소 복사 현재 작업공간에 remote repo 주소 추가 1$ git remote add origin 복사한주소 $ git remote get-url origin를 통해 주소 등록 여부 확인 빈 프로젝트면 $ touch README.md로 마크다운 파일 추가 프로젝트 상태확인 1$ git status untracked files: README.md 또는 git init 전에 파일들이 나열되어 있을것 $ git add README.md 또는 파일이 여러개일 경우 $ git add .를 사용해workspace에서 staging area로 이동 $ git commit -m &quot;메세지 내용&quot;을 입력하여 Commit message 작성커밋 방식은 Conventional commits 참조 ⚠️git commit -m을 사용해 커밋 메세지를 작성하면 수정하기 어려워 보통 텍스트 에디터를 설정하여 작성한다. 12$ git config --global core.editor &quot;vim&quot;$ git commit vim이 실행되면 i 를 눌러 편집모드(insert mode)로 들어간뒤 제목과 상세내용을 적어주면 된다. docs: 커밋 제목 **1. 커밋 메세지 상세내용1 ** **2. 커밋 메세지 상세내용2 ** # Please enter the commit message for your changes. Lines starting # with ‘#’ will be ignored, and an empty message aborts the commit. 작성후 :wq 를 입력하면 저장후 커밋 q! 를 입력하면 취소. 첫 push작업이라면 $ git push -u origin master를 이용해 remote repo로 push.이후에는 $ git push -u origin master 사용 새로운 파일, 변동사항이 있을때마다 7 ~ 10 반복 git clone github에서 remote repository를 LICENSE, README.md, .gitignore 등의 파일과 함께 생성 Clone or Download 버튼 클릭후 https 주소 복사 $ git clone 복사한주소 를 입력하여 local repository를 생성 새 파일을 만들거나 기존의 파일들 변경 $ git status로 프로젝트 상태확인 $ git add 파일이름 또는 $ git add .를 사용해 staging area에 추가 $ git commit으로 커밋 (방법은 git init 9번 참조) $ git push origin master로 변동사항 remote repository에 적용 변동사항 있을때마다 5~8번 반복하여 버전관리","link":"/2020/10/17/Git-%EC%B5%9C%EC%B4%88%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/"}],"tags":[{"name":"position","slug":"position","link":"/tags/position/"},{"name":"static","slug":"static","link":"/tags/static/"},{"name":"relative","slug":"relative","link":"/tags/relative/"},{"name":"absolute","slug":"absolute","link":"/tags/absolute/"},{"name":"BFC","slug":"BFC","link":"/tags/BFC/"},{"name":"CSS rendering","slug":"CSS-rendering","link":"/tags/CSS-rendering/"},{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"BEM","slug":"BEM","link":"/tags/BEM/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"convention","slug":"convention","link":"/tags/convention/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"git config","slug":"git-config","link":"/tags/git-config/"}],"categories":[{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","link":"/categories/HTML-CSS/CSS/"},{"name":"git","slug":"git","link":"/categories/git/"}]}